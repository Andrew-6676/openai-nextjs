import { GenerationResult } from '@/common';

interface GameData {
  grid: number[][];
  steps: number;
}

function parseInput(input: string): GameData | null {
  try {
    const parsedArray: string[] = [...(input.match(/\[[^\[\]]+]/g) ?? [])];
    const data = parsedArray.map((line) => JSON.parse(line));
    const steps = input.match(/(\d+)(?=\D*$)/g)?.[0] ?? 0;

    return data.length && steps
      ? {
          grid: data,
          steps: Number(steps),
        }
      : null;
  } catch (e) {
    return null;
  }
}

/*
  Generated by ChatGPT-4
 */
function gameOfLife({ grid, steps }: GameData) {
  let currentGrid = grid;

  const getNeighborsCount = (grid: number[][], x: number, y: number) => {
    const rows = grid.length;
    const cols = grid[0].length;
    let count = 0;

    for (let r = -1; r <= 1; r++) {
      for (let c = -1; c <= 1; c++) {
        if (r === 0 && c === 0) continue;
        const newRow = y + r;
        const newCol = x + c;

        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol] === 1) {
          count++;
        }
      }
    }

    return count;
  };

  const getNextGenerationGrid = (grid: number[][]) => {
    const rows = grid.length;
    const cols = grid[0].length;
    const nextGrid = new Array(rows).fill(null).map(() => new Array(cols).fill(0));

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const neighborsCount = getNeighborsCount(grid, row, col);
        const isCellAlive = grid[row][col] === 1;

        if (isCellAlive && (neighborsCount === 2 || neighborsCount === 3)) {
          nextGrid[row][col] = 1;
        } else if (!isCellAlive && neighborsCount === 3) {
          nextGrid[row][col] = 1;
        }
      }
    }

    return nextGrid;
  };

  for (let step = 0; step < steps; step++) {
    currentGrid = getNextGenerationGrid(currentGrid);
  }

  return currentGrid;
}

function generateImage(data: number[][]): ImageData {
  const cols = data[0].length;
  const rows = data.length;
  const blockSize = 13;
  const height = rows * blockSize;
  const width = cols * blockSize;

  const offscreenCanvas = new OffscreenCanvas(width, height);
  const ctx = offscreenCanvas.getContext('2d')!;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const isAlive = data[y][x];
      ctx.fillStyle = isAlive ? '#ffff00' : '#888888';
      ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
      ctx.strokeStyle = '#ffffff';
      ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
    }
  }

  return ctx.getImageData(0, 0, width, height);
}

onmessage = (e: MessageEvent<string>) => {
  const result: GenerationResult = {
    text: e.data,
  };
  const gameData = parseInput(e.data);

  console.debug('parsed input:', gameData);

  if (gameData) {
    const newGeneration = gameOfLife(gameData);
    console.time('Game time');
    result.image = generateImage(newGeneration);
    console.timeEnd('Game time');
  } else {
    result.message = 'There is no data to generate an image';
  }

  postMessage(result);
};
